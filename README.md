1. Подготовка среды Установить на виртуальной машине Debian 11/12 (VMware\\VirtualBox\\HyperV\\WSL). Убедиться, что система обновлена (команда apt-get update && apt-get upgrade – обязательно понимать разницу команд).

**apt-get update** – обновляет о доступных пакетах. Проверяет репозитории на наличие новых версий, но не устанавливает их.

**apt-get upgrade** \- устанавливает обновления для уже установленных пакетов.

**apt install** – для установки новых пакетов

**apt** – пакетный менеджер для управления пакетами

**пакеты** — это архивы, содержащие программное обеспечение, библиотеки, конфигурационные файлы и метаданные, необходимые для установки и управления программами в системе. Пакеты упрощают установку, обновление и удаление программ, а также управление зависимостями между ними.

1. [**http://security.debian.org/debian-security**](http://security.debian.org/debian-security) **bookworm-security InRelease**:
    - Это репозиторий безопасности для Debian. Он содержит обновления, связанные с безопасностью, для вашей версии Debian (в данном случае — bookworm).
    - InRelease — это файл, содержащий информацию о пакетах в репозитории, включая их подписи для проверки подлинности.
2. [**http://deb.debian.org/debian**](http://deb.debian.org/debian) **bookworm InRelease**:
    - Это основной репозиторий Debian для версии bookworm. Он содержит большинство пакетов, включая основные программы и библиотеки.
    - InRelease — аналогично, файл с информацией о пакетах.
3. [**http://deb.debian.org/debian**](http://deb.debian.org/debian) **bookworm-updates InRelease**:
    - Это репозиторий обновлений для версии bookworm. Он содержит обновления пакетов, которые не связаны с безопасностью, но важны для стабильности и функциональности системы.
    - InRelease — файл с информацией о пакетах.
4. Установка PostgreSQL С помощью пакетного менеджера apt установить PostgreSQL (последнюю доступную версию из репозиториев). Привести команды установки и их объяснение.

Для установки PostgreSQL использовали команду

# sudo apt install postgresql

sudo: Выполнение команд, требующих прав root apt: Пакетный менеджер для управления пакетами

**Отличие** sudo **от** su:

- - sudo выполняет одну команду с правами root, а su переключает пользователя на root (или другого пользователя) до тех пор, пока вы не выйдете из сессии.
    - sudo требует пароль текущего пользователя, а su — пароль целевого пользователя (обычно root).

После установки при помощи **sudo systemctl status postgresql** проверили статус

postgres, точно ли он установился и правильно ли он работает.

1. Создание служебной учётной записи. Проверить, что при установке создана учётная запись postgres. Объяснить её назначение и права в системе.

Командой **sudo -i -u postgres** переключились на пользователя postgres

# sudo

- - Это команда, которая позволяет выполнять другие команды с привилегиями суперпользователя (root) или другого пользователя. В данном случае она используется для переключения на пользователя postgres.

1. **\-i**:
    - Этот флаг указывает sudo запустить **интерактивную оболочку (login shell)**. Это означает, что будет загружена среда пользователя, включая его переменные окружения, профили и настройки оболочки.
    - По сути, это аналогично входу в систему как пользователь postgres.

# \-u postgres

- - Этот флаг указывает sudo переключиться на пользователя postgres. Вместо выполнения команды от имени root, команда будет выполнена от имени указанного пользователя.

После того, как зашли postgres-пользователем запустили терминал PostgreSQL командой

# psql

**Назначение пользователя postgres**

- Пользователь postgres создаётся автоматически при установке PostgreSQL. Он является владельцем всех файлов, связанных с PostgreSQL, включая:
- Пользователь postgres используется для запуска и остановки сервера

PostgreSQL.

- Все процессы PostgreSQL (например, postmaster) запускаются от имени этого пользователя.
- Пользователь postgres имеет полный доступ ко всем базам данных, таблицам и другим объектам в PostgreSQL.
- Он может создавать, изменять и удалять базы данных, пользователей и роли.

# Права пользователя postgres

- Пользователь postgres является владельцем каталога данных PostgreSQL (например, /var/lib/postgresql).
- Он имеет права на чтение, запись и выполнение в этом каталоге и его подкаталогах.
- Внутри PostgreSQL пользователь postgres имеет роль суперпользователя

(superuser).

- Пользователь postgres обычно не имеет прав суперпользователя (root) в системе. Это сделано для безопасности. Однако он может выполнять команды, связанные с управлением PostgreSQL, такие как запуск и остановка сервера.

1. Первичная настройка конфигурационных файлов Найти и изучить основные файлы конфигурации PostgreSQL (например, postgresql.conf, pg_hba.conf). Внести изменения (например, задать порт, при необходимости изменить метод аутентификации) и перезапустить сервис PostgreSQL.

Файл postgresql.conf в самом начале. Будем менять строку listen_adress, отвечающую за настройку сетевых интерфейсов (именно в ней прописаны адреса, с которых доступно подключение к postgresql). По умолчанию у данного параметра стоит значение localhost, что значит, что подключение доступно только в Debian. Для того, чтобы в дальнейшем иметь возможность подключения и в window на нашем устройстве, заменим значение этого параметра на \*, тем самым давая возможность подключения со всех адресов.

Командой **sudo nano /etc/postgresql/15/main/postgresql.conf** заходим в файл и редактируем строку, описанную выше. Сохраняем изменения и перезапускаем нас сервер при помощи **sudo systemctl restart postgresql**

1. Управление сервисом Использовать инструменты управления сервисами Debian

(systemd) — проверить статус сервиса PostgreSQL, включить автозапуск.

Для включения автозапуска использовали команду **sudo systemctl enable postgresql** (enable - подкоманда systemctl, которая включает автозапуск сервиса при загрузке системы)

1. Создание тестовой базы данных Создать отдельного пользователя (логин задать в формате ФИО, например, alpopov) в PostgreSQL, новую базу данных (нейминг аналогичен dbalpopov), задать ему пароль. Использовать psql, чтобы проверить

доступ.

Для создания нового пользователя использовали PSQL-запись:

# CREATE USER &lt;userName&gt; WITH PASSWORD ‘&lt;userPassword&gt;’

После этого для нового пользователя создали базу данных, так же используя PSQL-

запись:

# CREATE DATABASE &lt;dbName&gt; OWNER &lt;userName&gt

Для того, чтобы проверить, точно ли все создалось как надо использовали команды:

- **\\du** \- возвращает список пользователей (ролей) в PostgreSQL, а также их атрибуты и привилегии.
- **\\l** \- возвращает список баз данных на сервере PostgreSQL.

При входе в psql от лица нового пользователя была проблема в том, postgres ругался на проверку подлинности нового пользователя, связано это было с тем, что в файле pg_hba.conf была строка:

local all all peer,

В которой значение peer говорит о том, что postgresql разрешает подключение только тем пользователям, что есть в системе Linux. Чтобы это исправить и сделать возможным вход по паролю пользователя заменили peer на md5

local all all md5

после этого любой пользователь postgresql может войти использую свой пароль, который мы ранее использовали для создания.

Далее, для подключения к базе от лица нового пользователя прописали:

# psql -U &lt;userName&gt; -d &lt;dbName&gt; -W

И для окончательной проверки того, что зашли мы не от лица postgres вызвала командой

**SELECT current_user;** имя пользователя текущей сессии.

Однако, когда мы пошли делать следующие задания столкнулись с проблемой, что теперь перед запуском psql требуется пароль postgres-пользователя, который мы не задавали и который пустым не являлся. Далее в лабораторной работе мы его поменяем, но пока, чтобы обойти эту проблему в pg_hba.conf вернули строку

local all all peer

1. Знакомство со схемами. Объяснить, что такое схема в PostgreSQL, в чём разница между базой данных и схемой. По умолчанию существует схема public. Создайте ещё одну схему, например, test_schema. Настройте у пользователя, созданного выше, права на использование этой схемы (команда GRANT). Продемонстрируйте, как работать с разными схемами (смена search_path или обращение к объектам через test_schema.table_name).

База данных — это основное хранилище, в котором могут находиться схемы. В ней хранятся:

- Схемы (как папки для структурирования данных).
- Пользователи и их права доступа.
- Журналы транзакций.
- Настройки базы данных.

Схема — это область внутри базы данных, в которой хранятся объекты, в том числе и таблицы, в которых храниться информация

Для создания новой схемы используется команда

# CREATE SCHEMA &lt;schemaName&gt

Для предоставления прав на использование объектов схемы:

# GRANT USAGE ON SCHEMA &lt;schemaName&gt; TO &lt;userName&gt

Для предоставления прав на создание объектов в схеме пользователем используется:

# GRANT CREATE ON SCHEMA &lt;schemaName&gt; TO &lt;userName&gt

Для проверки вызвали **/dt+**, который возвращает список схем и их описание. В нем же видим, что пользователь asstarikova в схеме test_schema может:

- **U** — USAGE (право на использование объекта, например, схемы или последовательности).
- **C** — CREATE (право на создание объектов в схеме).

# SET search_path TO &lt;schemaName&gt

позволяет указать, в каких схемах PostgreSQL будет искать объекты, если схема не указана явно.

**search_path** — это список схем, которые PostgreSQL проверяет при поиске объектов. По умолчанию search_path включает схему public, а также схему, соответствующую имени текущего пользователя. Если объект не указан с явным именем схемы

(например, schema_name.table_name), PostgreSQL ищет его в схемах, перечисленных в search_path, в порядке их указания.

1. Использование утилиты psql для базовых операций. В схеме public создать тестовую таблицу, внести несколько записей, выполнить основные SQL-запросы (SELECT, INSERT, UPDATE, DELETE). В схеме из 7 задания test_schema создать другую таблицу и внести несколько записей. Покажите, как к ней обращаться. Использовать скрипт, который демонстрирует создание таблицы с привязкой к конкретной схеме.

Для создания таблицы использовали метод

# CREATE_TABLE &lt;tableName&gt; (&lt;tableColumns with types&gt;)

Где вместо **tableColumns with types** указывает названия столбцов и тип данных, который будет в них использоваться.

Методом **\\d &lt;schema.table&gt;** получили все поля с типами данных, которые они ожидают у определенной таблицы.

Для заполнения таблицы данными использовали

# INSERT INTO &lt;schema.table&gt; (&lt;columns&gt;) VALUES (&lt;data&gt;)

Где &lt;columns&gt; - названия столбцов, в которые будут вноситься данные, а &lt;data&gt; - как раз-таки данные, которые будут записываться.

После для того, чтобы проверить, что все записалась куда надо прописали

# SELECT \* FROM &lt; schema.table &gt

Где \* означает, что должны быть выведены значения всех столбцов.

Если же нам потребовалось вывести значения одного или нескольких столбцов, но не всей таблицы, то можно было бы перечислить их названия вместо \*.

В существующей таблице записи изменили значение поля name на другое, используя:

# UPDATE &lt;schema.table&gt; SET &lt;columnName&gt; WHERE &lt;condition&gt

Где schema.table – название таблицы, данные в которой мы будем редактировать, columnName – название столбца, в котором мы будем менять значения, condition – условие, по которому мы находим нужную строку, в которой будут происходить

изменения

Добавили новую запись уже известным методом INSERT INTO и после этого удалили ее при помощи записи:

# DELETE FROM &lt; schema.table &gt; WHERE &lt;condition&gt;

Где schema.table – название таблицы, данные в которой мы будем редактировать, columnName – название столбца, в котором мы будем менять значения, condition – условие, по которому мы находим нужную строку, в которой будут происходить

изменения

Создали еще одну таблицу и тоже заполнили ее данными. Вывели их значения.

1. Настройка локальных и сетевых подключений Настроить доступ к базе данных по локальной сети (например, разрешить подключаться к PostgreSQL с другого хоста). Объяснить параметры listen_addresses и формат строки в pg_hba.conf. Произвести подключение через pgadmin или dbeaver с локальной машины.

В начале лабораторной работы меняли файл конфигурации postgresql.conf, чтобы разрешить PostgreSQL слушать соединения с других хостов.

- - В нем нашли параметр listen_addresses, который указывает, на каких IP-адресах PostgreSQL будет слушать соединения. И изменили его значение на:

listen_addresses = '\*'

Это позволит PostgreSQL слушать на всех доступных IP-адресах. Для редактирования файлов использовали

Далее - настроили файл доступа pg_hba.conf, чтобы разрешить подключения с других хостов.

- - host — указывает, что подключение происходит через TCP/IP.
    - all — означает, что разрешены подключения ко всем базам данных.
    - all — разрешение для всех пользователей.
    - 192.168.1.0/24 — это диапазон IP-адресов сети, которому разрешено подключаться. Мы будем использовать 0.0.0.0/0, которые позволяет подключаться к серверу со всех адресов.
    - md5 — метод аутентификации, который требует использования пароля, зашифрованного методом MD5.

host all all 0.0.0.0/0 md5

После того, как сделали возможным подключение к нашему postgres-серверу, командой

**ip a** узнали адрес нашего сервера, по которому будем подключаться в pgAdmin

В настройках виртуальной машины сменили настройку параметра **Attached to: на Bridged Adapter.** Это нужно для того, чтобы виртуальная машина была доступна из внешней сети. По факту в этом режиме виртуальная машина становится полноценным

участником сети, получает IP-адрес из той же сети, что и хост, и может взаимодействовать с другими устройствами в сети.

В pgAdmin создали новый сервер и перешли по вкладке Register -> Server. В Connection

заполняем поля:

Host nаme/address – адрес виртуальной машины, который мы получили методом ip a на

Debian

Port – 5432 – значение по умолчанию, которое используется на postgres-серверах Username – имя пользователя, от которого мы будет подключаться к бд

Password – пароль пользователя, который мы указали ранее писали, что postgres – пользователь, который создается автоматически и пароль от которого мы не знаем. Методом **ALTER USER &lt;userName&gt; WITH PASSWORD '&lt;newPassword&gt;';** мы изменили пароль пользователя, на известный нам)

После всех этих действий мы имеем доступ к нашему серверу на Debian с windows.

1. Журналирование (logging). Изменить настройки журналирования в postgresql.conf, перезапустить сервис и проверить, как новые логи записываются. Найти логи в Debian и вывести примеры строк лога.

Для того, чтобы настроить журналирование изменили очень много строк в файле postgresql.conf.

# Основные параметры логирования

l**ogging_collector = on**

Включает сборщик логов PostgreSQL. Если этот параметр выключен (off), логи могут записываться в syslog или journald (в зависимости от системы), но не в отдельный файл. Нужно чтобы PostgreSQL записывал логи в файлы, а не только в системный журнал.

# log_directory = 'log'

Определяет каталог, куда PostgreSQL будет сохранять файлы логов. По умолчанию log, но можно изменить, например:

# log_filename = 'postgresql.log'

Определяет имя файла лога.

# log_statement = 'all'

Определяет, какие SQL-запросы логировать. Возможные значения:

- none — не записывать SQL-запросы.
- ddl — записывать только изменения структуры БД (CREATE, ALTER, DROP).
- mod — записывать изменения данных (INSERT, UPDATE, DELETE, TRUNCATE).
- all — записывать все запросы.

# log_min_messages = info

Определяет минимальный уровень сообщений, которые будут записываться в лог. Возможные значения:

- debug5, debug4, debug3, debug2, debug1 — детальное отладочное логирование.
- info — информационные сообщения.
- notice — важные, но не критические уведомления.
- warning — предупреждения.
- error — ошибки, но сервер продолжает работать.
- fatal — критические ошибки, приводящие к завершению соединения.
- panic — серверная ошибка, требующая перезапуска.

# log_min_error_statement = error

Определяет минимальный уровень ошибок, при котором в лог будет записываться **сам SQL-запрос, вызвавший ошибку**. Нужно чтобы видеть не только ошибки, но и **какие запросы их вызвали**.

# Пример вывода в логе, если log_min_error_statement = error

2025-03-19 12:35:25 UTC \[12349\] ERROR: relation "customers" does not exist 2025-03-19 12:35:25 UTC \[12349\] STATEMENT: SELECT \* FROM customers;

Здесь видно, что ошибка relation "customers" does not exist была вызвана запросом

SELECT \* FROM customers;.

# log_connections = on

Логирует все новые подключения к базе данных. Позволяет отслеживать, кто и когда подключался.

# log_disconnections = on

Логирует отключения пользователей от базы данных. Позволяет видеть, как долго длилась сессия.

# ▶ Пример вывода в логе

2025-03-19 12:42:10 UTC \[12350\] LOG: disconnection: session time: 0:02:09 user=postgres database=mydb host=192.168.1.100 port=54321

Здесь видно, что пользователь postgres работал в базе mydb 2 минуты 9 секунд.

1. Назначение ролей и прав Создать роль с ограниченными привилегиями и протестировать, какие операции она может выполнять (роль назвать limited_user). Продемонстрировать, как в PostgreSQL наследуются права между ролями. Объяснить выдачу прав через GRANT.

Для создания роли, точнее – пользователя использовали

# CREATE ROLE &lt;roleName&gt; WITH LOGIN PASSWORD &lt;rolePassword&gt

Для создания просто роли, не пользователя необходимо прописать

# CREATE ROLE &lt;roleName&gt

Отличие пользователя от роли заключается в том, что пользователь может входить в базу, иметь пароль, так же пользователь не может использоваться как группа. Роль же может объединять пользователей и давать им какие-то определенное привилегии.

Для того, чтобы добавить прав роли/пользователю использовали:

GRANT &lt;rights&gt; ON &lt;tableName&gt; TO &lt;role&gt;;

Где rights – одно или несколько из значений:

- **SELECT** — право на чтение данных (выполнение запросов SELECT).
- **INSERT** — право на вставку новых строк (выполнение запросов INSERT).
- **UPDATE** — право на обновление существующих строк (выполнение запросов UPDATE).
- **DELETE** — право на удаление строк (выполнение запросов DELETE).
- **TRUNCATE** — право на очистку таблицы (выполнение команды TRUNCATE).
- **REFERENCES** — право на создание внешних ключей (FOREIGN KEY), ссылающихся на эту таблицу.
- **ALL PRIVILEGES** — все доступные права на таблицу.

Данным запросом мы можем просмотреть, какими именно привилегиями обладает роль

limited_user, а именно - может просматривать данные в таблице test схемы public.

Так роль, которую мы создали ранее имеет доступ только с просмотром данных внутри бд. При попытке изменения и удаления возникает ошибка о том, что у нас нет доступа к таблице.

Тут же мы создали роль limited, которая унаследовала все права роли limited_user так же при помощи метода GRANT:

# GRANT &lt;role with rights&gt; TO &lt;role without rights&gt

Где &lt;role with rights&gt; - роль, которая передает свои права и делает своим членом роль

&lt;role without rights&gt;.
